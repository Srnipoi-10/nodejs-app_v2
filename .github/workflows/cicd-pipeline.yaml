name: Docker Image CI/CD

on:
  push:
    branches: ["dev", "main", "feature/**"]
  pull_request:
    branches: ["dev"]

jobs:
  # Логин в Docker Hub на builder
  login-docker-hub:
    runs-on: [self-hosted, builder]  # Указание на self-hosted и builder
    steps:
      - uses: actions/checkout@v3
      - name: Login to Docker Hub
        run: |
          echo "${{ secrets.DOCKERHUB_PASSWORD }}" | docker login -u "${{ secrets.DOCKERHUB_USER }}" --password-stdin

  build-and-push:
  needs: login-docker-hub
  runs-on: [self-hosted, builder]  # Указание на self-hosted и builder
  steps:
    - name: Determine the repository based on the branch
      id: set-repository
      run: |
        # Проверка ветки и установка правильного репозитория
        if [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
          echo "REPO=prod" >> $GITHUB_ENV  # Для ветки main
        elif [[ "${{ github.ref }}" == "refs/heads/dev" || "${{ github.ref }}" == refs/heads/feature/* ]]; then
          echo "REPO=dev" >> $GITHUB_ENV  # Для веток dev и feature/*
        else
          echo "REPO=unknown" >> $GITHUB_ENV  # Если ветка не соответствует
        fi
        echo "Repository is set to ${{ env.REPO }}"

    - name: Build and Push Docker Image
      env:
        IMAGE_NAME: ${{ secrets.DOCKERHUB_USER }}/${{ env.REPO }}  # Используем переменную REPO для определения репозитория
      run: |
        # Создание тега с заменой "/" на "-"
        TAG="$(echo "${{ github.ref_name }}" | sed 's|/|-|g')-${{ github.run_number }}"
        echo "Building image: $IMAGE_NAME:$TAG"
        
        # Сборка образа Docker
        docker build -t $IMAGE_NAME:$TAG .
        
        # Публикация образа в Docker Hub
        docker push $IMAGE_NAME:$TAG
        
        # Удаление локального образа после публикации
        docker rmi $IMAGE_NAME:$TAG

  # Деплой на dev
  deploy-dev:
    # Условие для деплоя на dev: выполняется для веток 'dev' и 'feature/**'
    if: startsWith(github.ref, 'refs/heads/dev') || startsWith(github.ref, 'refs/heads/feature/')
    runs-on: [self-hosted, dev]  # Указание на self-hosted и dev
    environment: DEV  # Указание окружения для dev
    needs: build-and-push
    steps:
      - name: Deploy Application to DEV
        env:
          # Получение имени образа для деплоя на dev
          IMAGE_NAME: ${{ secrets.DOCKERHUB_USER }}/${{ vars.REPOSITORY }}  # Используем vars для получения имени репозитория
        run: |
          # Формирование тега с учетом ветки и номера выполнения
          TAG="${{ github.ref_name }}-${{ github.run_number }}"
          echo "Deploying image: $IMAGE_NAME:$TAG to DEV"
          
          # Удаление старого контейнера, если он существует
          docker rm -f app || true
          
          # Запуск нового контейнера с нужным образом
          docker run -d -p 80:80 --name app $IMAGE_NAME:$TAG

  # Деплой на prod
  deploy-prod:
    # Условие для деплоя на prod: выполняется для ветки 'main'
    if: startsWith(github.ref, 'refs/heads/main')
    runs-on: [self-hosted, prod]  # Указание на self-hosted и prod
    environment: PROD  # Указание окружения для prod
    needs: build-and-push
    steps:
      - name: Deploy Application to PROD
        env:
          # Получение имени образа для деплоя на prod
          IMAGE_NAME: ${{ secrets.DOCKERHUB_USER }}/${{ vars.REPOSITORY }}  # Используем vars для получения имени репозитория
        run: |
          # Формирование тега с учетом ветки и номера выполнения
          TAG="${{ github.ref_name }}-${{ github.run_number }}"
          echo "Deploying image: $IMAGE_NAME:$TAG to PROD"
          
          # Удаление старого контейнера, если он существует
          docker rm -f app || true
          
          # Запуск нового контейнера с нужным образом
          docker run -d -p 80:80 --name app $IMAGE_NAME:$TAG
